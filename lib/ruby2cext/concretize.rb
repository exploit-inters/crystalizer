require 'rubygems'
require 'ruby2ruby'
require 'parse_tree'
require 'thread' # mutex
require 'sane'
# LTODO singleton methods, class methods, [procs?]

module Ruby2CExtension

  class Concretize

    def Concretize.source_for klass, method_name
      raw = @@pt.parse_tree_for_method(klass, method_name)
      begin
        processed = @@pt.process(raw)
      rescue
        return nil
      end
      code = @@r2r.process( processed )
      if code.include?('&block') || code.include?('binding')
        # eval?
        # for now, try to avoid the tripsy case of ruby2cext not yielding arrays right yet...
        # TODO add some test cases for it in 'broken.rb' or something
        # LTODO fix it :)

        # TODO test it with rdoc...yeah. A real test sniff
        # compare with 1.9...
        nil
      else
        code
      end
    end


    begin
      @@good_codes ||= YAML.load File.read('known_good_codes')
    rescue Exception
      @@good_codes = {}
    end

    at_exit {
      puts 'saving'
      File.write 'known_good_codes', YAML.dump(@@good_codes)
    }
    @@count = 0
    @@mutex = Mutex.new
    @@r2r = Ruby2Ruby.new
    @@pt = ParseTree.new

    # returns rb code, or c code, or true on successfull load
    # returns nil if want_rb_afterward && had to compile
    # which is ok
    def Concretize.c_ify! klass, method_name, want_rb_afterward = false, want_just_c = false
      count = @@mutex.synchronize { @@count += 1 }
      rb = "temp_#{count}.rb"
      ruby_code = source_for klass, method_name

      # TODO it probably catches railsy class style poorly [re-use my other desc_method?]
      return nil unless ruby_code
      

      assert klass.class.in?( [Class, Module]) # sanity check
      comment = "# concretize temp file: autogenerated: #{ Time.now }\n"
      if klass.class == Module
        klass_string = "module #{klass}" # modules don't descend
      else
        nearest_ancestor = klass.ancestors[1..-1].find{|ancestor| ancestor.class == Class}
        if nearest_ancestor
          klass_string = "class #{klass} < #{nearest_ancestor}"
        else
          # Object, I suppose
          klass_string = "class #{klass}"
        end
      end
      
      ruby_code_wrapped = comment + klass_string + "\npublic\n" + ruby_code +  "\nend\n"
      @@log.debug ruby_code_wrapped
      if @@good_codes[ruby_code] && want_rb_afterward
        @@log.debug 'cache hit'
        @@cache_hits+= 1
        return ruby_code_wrapped
      else
        #_dbg
        @@log.debug 'cache miss' + @@good_codes.length.to_s
      end

      # sometimes ruby2ruby unpacks them wrong, so test for that
      File.open(rb, 'w') do |file|
        file.write ruby_code_wrapped
      end
      output = `ruby -c #{rb} 2>&1`
      if($?.exitstatus != 0)
        # unparsable ruby was generated...hmm...
        @@log.warn "got bad code generation", klass, method_name, ruby_code
        File.delete rb
        return nil # LTODO re-parse it [other parser?] make sure reparsing matches...
      else
        # see if it passes, below, too
      end


      if want_just_c
        return Concretize.compile_string(ruby_code_wrapped, want_just_c)
      else
        success = Concretize.compile_string(ruby_code_wrapped) rescue nil # can fail, like ...ensure; return nil
        if success
          @@good_codes[ruby_code] = true          
          
          if want_rb_afterward
            return ruby_code_wrapped # no new [helpful] ruby code here, but pass it out anyway..
          end
        end
        success
      end
    end

    @@cache_hits = 0
    def self.cache_hits
      @@cache_hits #ltodo attr_reader?
    end
    def self.good_codes
      @@good_codes
    end
    
    @@log = Logger.new (STDOUT)
    private
    # returns the c code, or the .so filename if it was compiled and run


    def Concretize.compile_string(ruby_string, want_just_c = false)
      file_name = "temp_#{@@count += 1}" # has to be .rb for some reason
      File.write file_name + '.rb', ruby_string

      Compiler.compile_file(file_name + '.rb', {:optimizations => :all}, [], false, @@log)
      #LTODO delete all temp files -- except we can't delete .so files once loaded...
      c_file = file_name + '.c'
      so_file = file_name + '.so'

      if(want_just_c)
        return File.read(c_file)
      end
      # LTODO make it multi process friendly, too :)
      require so_file # return just the name? huh?
    end

    public
    
    @@already_cified = {}
    # pass in a class name instnace
    # like c_ify_class! ClassName
    # currently only cifys the singleton methods...
    # add_to_string is either nil or a string.
    # returns whether that class and all ancestors had something ruby-y that it successfully converted to C
    def Concretize.c_ify_class! klass, add_to_string = nil, skip_ancestors = false
      
      local_add_to_string = ''
      
      Ruby2CExtension::Plugins::DirectSelfCall.allow_public_methods # we're concretizing, so public methods are ok
      # TODO test that this actually does something to the C code :)
      success = false
      # LTODO class methods, singleton methods...sure! :)
      ancestors = [klass]
      
      if(!skip_ancestors)
        ancestors = klass.ancestors
      end
      
      for klass in ancestors # ltodo reverse...
        if @@already_cified[klass]
          # for now we keep all classes as real classes [not really concretize anything...we just c-ify everything aggressively]
          # when that is fixed be careful to get the inheritance wrong if two ancestors define the same method
          next
        end
        # TODO optionally take out all private checks :)
        for method_name in klass.instance_methods(false)
          if(!add_to_string)
            success |= Concretize.c_ify! klass, method_name
          else
            string = Concretize.c_ify!(klass, method_name, true)
            if(string)
              local_add_to_string << " " << string
              success = true
            end
          end
        end
        
        if add_to_string
          add_to_string << local_add_to_string
        else
          Concretize.compile_string(local_add_to_string)
        end
        
        @@already_cified[klass] = true

        print klass.to_s + " has "
        if(!success)
          print "no "
        end
        puts "ruby methods"
      end

      return success
    end

    # turn all classes' ruby methods into their C equivalents
    # deemed unstable as of yet :(
    def Concretize.concretize_all! classes_to_do = nil, all_together = true
      @@already_cified = {} # in case things have changed...maybe?
      if !classes_to_do
        classes_to_do = []
        ObjectSpace.each_object(Class){|c| classes_to_do << c}
      end

      all_successful = []
      if all_together
        all_ruby_codes = ''
      else
        all_ruby_codes = nil
      end

      classes_to_do.each{|klass|
        all_successful << klass if Concretize.c_ify_class!(klass, all_ruby_codes)
      }
      # puts 'none found' if all_ruby_codes == '' this is expected currently anytime after the first run...
      Concretize.compile_string(all_ruby_codes)
      all_successful
    end
  end

  require 'event_hook' # 1.8 only for now [sigh]
  class Tracer < EventHook
    class << self
      def all_classes
        @all_classes.keys
      end
      def start
        @all_classes = {}
        start_hook
      end
      def process(*args)
        # like [16, Tracer, :get_line, Tracer]
        # not sure what [1] is versus [3]
        @all_classes[args[3]]= true
      end
    end
  end

  def Concretize.crystalize_after_first_time_through
    raise unless block_given?
    Tracer.start
    yield
    Tracer.stop_hook
    raise unless Tracer.all_classes.length > 0
    puts 'crystalizing', Tracer.all_classes.inspect
    Concretize.concretize_all! Tracer.all_classes
  end
end

class Class
  # somewhat of a misnomer TODO rdoc
  def concretize!
    Ruby2CExtension::Concretize.c_ify_class! self
  end
end

class Object
  def concretize_ruby!
    Ruby2CExtension::Concretize.concretize_all!
  end
end



