require 'rubygems'
require 'ruby2ruby'
require 'parse_tree'
require 'thread' # mutex
require 'sane'
require 'backports'
# LTODO singleton methods, class methods, [procs?]

module Ruby2CExtension

  class Concretize

    def Concretize.source_for klass, method_name
      raw = @@pt.parse_tree_for_method(klass, method_name)
      begin
        processed = @@pt.process(raw)
      rescue
        return nil
      end
      code = @@r2r.process( processed )
      if code.include?('&block')
        # for now, try to avoid the tripsy case of ruby2cext not yielding arrays right yet...
        # TODO add some test cases for it in 'broken.rb' or something
        # LTODO fix it :)
        nil
      else
        code
      end
    end 

    @@count = 0
    @@mutex = Mutex.new
    @@r2r = Ruby2Ruby.new
    @@pt = ParseTree.new
    def Concretize.c_ify! klass, method_name, want_just_rb = false, want_just_c = false
      source_for(String, :to_c_strlit)
      count = @@mutex.synchronize { @@count += 1 }
      rb = "temp_#{count}.rb"
      code = source_for klass, method_name

      # TODO it probably catches railsy class style poorly [re-use my other desc_method?]
      return nil unless code
      File.open(rb, 'w') do |file|
        file.write code
      end
      output = `ruby -c #{rb} 2>&1`
      File.delete rb
      if($?.exitstatus != 0)
        # unparsable ruby was generated...hmm...
        puts "got bad code generation", klass, method_name, code
        return nil # TODO re-parse it [other parser?] make sure it matches [?]
      end
      
      #assert klass.class.in?( [Class, Module]) # sanity check
      comment = "# concretize temp file: autogenerated: #{ Time.now }\n"
      if klass.class == Module
        klass_string = "module #{klass}" # modules don't descend
      else
        nearest_ancestor = klass.ancestors[1..-1].find{|ancestor| ancestor.class == Class}
        if nearest_ancestor
          klass_string = "class #{klass} < #{nearest_ancestor}"
        else
          # Object, I suppose
          klass_string = "class #{klass}"
        end
      end        
      code = comment + klass_string + "\npublic\n" + code +  "\nend\n"
      
      if(want_just_rb)
        return code
      end
      File.open(rb, 'w')  do |out|
        out.write( code )
      end
      puts code # ruby code
      #LTODO delete temp file
      return Concretize.compile(rb, want_just_c) rescue nil # might not be compatible here
    end

    private
    def Concretize.compile(rb, want_just_c)
      Compiler.compile_file(rb, {:optimizations => :all}, [], false, Logger.new( STDOUT ) )
      c_file = rb[0..-4] + '.c'
      so_file = rb[0..-4] + '.so'

      if(want_just_c)
        return File.read(c_file)
      end
      # LTODO make it multi process friendly, too :)
      require so_file
    end
    public
    @@already_cified = {}
    # pass in a class name instnace
    # like c_ify_class! ClassName
    # currently only cifys the singleton methods...
    # add_to_string is either nil or a string.
    # returns whether that class and all ancestors had something ruby-y that it successfully converted to C
    def Concretize.c_ify_class! klass, add_to_string = nil
      Ruby2CExtension::Plugins::DirectSelfCall.allow_public_methods # we're concretizing, so public methods are ok
      # TODO test that this actually does something to the C code :)
      success = false
      # LTODO class methods, singleton methods...sure! :)
      for klass in klass.ancestors # ltodo reverse...
      	if @@already_cified[klass] 
          # for now we keep all classes as real classes [not really concretize anything...we just c-ify everything aggressively]
        	# when that is fixed be careful to get the inheritance wrong if two ancestors define the same method
          next
        end
        # TODO optionally take out all private checks :)
        for method_name in klass.instance_methods(false)
          if(!add_to_string)
          	success |= Concretize.c_ify! klass, method_name
          else
            string = Concretize.c_ify!(klass, method_name, true)
            if(string)
              add_to_string << " " << string
              success = true
            end
          end
        end
        @@already_cified[klass] = true
      
	      print klass.to_s + " has "
	      if(!success)
	        print "no "
	      end
	      puts "ruby methods"
      end

      return success
    end

    # turn all classes' ruby methods into their C equivalents
    # deemed unstable as of yet :(
    def Concretize.concretize_all! classes_to_do = nil
    	@@already_cified = {} # in case things have changed...maybe?    
    	if !classes_to_do
    	  classes_to_do = []
        ObjectSpace.each_object(Class){|c| classes_to_do << c}
      end
      
      all_successful = []
      classes_to_do.each{|klass|
        all_successful << klass if Concretize.c_ify_class!(klass)
      }
      all_successful
    end
  end
  
  
  require 'event_hook' # 1.8 only for now [sigh]
  class Tracer < EventHook
    class << self
      def all_classes
        @all_classes.keys
      end
      def start
        @all_classes = {}
        start_hook
      end
      def process(*args)
        # like [16, Tracer, :get_line, Tracer]
        # not sure what [1] is versus [3]
        p args
        @all_classes[args[3]]= true
      end    
    end
  end
  
  def Concretize.crystalize_after_first_time_through
     raise unless block_given?
     Tracer.start
     yield
     Tracer.stop_hook
     raise unless Tracer.all_classes.length > 0
     puts Tracer.all_classes.inspect
     Concretize.concretize_all! Tracer.all_classes
  end
end

class Class
	# somewhat of a misnomer TODO rdoc
  def concretize!
    Ruby2CExtension::Concretize.c_ify_class! self
  end
end

class Object
 def concretize_ruby!
   Ruby2CExtension::Concretize.concretize_all!
 end
end



