require 'rubygems'
require 'ruby2ruby'
require 'parse_tree'
require 'thread' # mutex
require 'sane'

# LTODO singleton methods, class methods, [procs?]

module Ruby2CExtension

  class Concretize
    @@count = 0
    @@mutex = Mutex.new
    @@r2r = Ruby2Ruby.new
    @@pt = ParseTree.new
    def Concretize.c_ify! klass, method_name, want_just_rb = false, want_just_c = false
      count = @@mutex.synchronize { @@count += 1 }
      rb = "temp_#{count}.rb"
      code = @@r2r.process( @@pt.process(@@pt.parse_tree_for_method(klass, method_name)) ) rescue nil
      # TODO it probably catches railsy class style poorly [re-use my other desc_method?]
      return nil unless code
      File.open(rb, 'w') do |file|
        file.write code
      end
      output = `ruby -c #{rb} 2>&1`
      File.delete rb
      if($?.exitstatus != 0)
        # unparsable ruby was generated...hmm...
        puts "got bad code generation", klass, method_name, code
        return nil
      end
      
      nearest_ancestor = klass.ancestors[1..-1].find{|ancestor| ancestor.class == Class}
      code = "# concretize temp file: autogenerated: #{ Time.now }\n" +
      "class #{klass} < #{nearest_ancestor}\n" + code + "\nend\n"
      
      if(want_just_rb)
        return code
      end
      File.open(rb, 'w')  do |out|
        out.write( code )
      end
      puts code # ruby code
      #LTODO delete temp file
      return Concretize.compile(rb, want_just_c) rescue nil # might not be compatible here
    end

    private
    def Concretize.compile(rb, want_just_c)
      Compiler.compile_file(rb, {:optimizations => :all}, [], false, Logger.new( STDOUT ) )
      c_file = rb[0..-4] + '.c'
      so_file = rb[0..-4] + '.so'

      if(want_just_c)
        return File.read(c_file)
      end
      # LTODO make it multi process friendly, too :)
      require so_file
    end
    public
    @@already_cified = {}
    # pass in a class name instnace
    # like c_ify_class! ClassName
    # currently only cifys the singleton methods...
    # add_to_string is either nil or a string.
    def Concretize.c_ify_class! klass, add_to_string = nil
      Ruby2CExtension::Plugins::DirectSelfCall.allow_public_methods # we're concretizing, so public methods are ok
      # TODO test that this actually does something to the C code :)
      success = false
      # LTODO class methods, singleton methods...sure! :)
      for klass in klass.ancestors
      	if @@already_cified[klass] 
          # for now we keep all classes as real classes [not really concretize anything...we just c-ify everything aggressively]
        	# when that is fixed be careful to get the inheritance wrong if two ancestors define the same method
          next
        end
        # TODO take out private checks
        for method_name in klass.instance_methods(false)
          if(!add_to_string)
          	success |= Concretize.c_ify! klass, method_name
          else
            string = Concretize.c_ify!(klass, method_name, true)
            if(string)
              add_to_string << " " << string
              success = true
            end
          end
        end
        @@already_cified[klass] = true
      
	      print klass.to_s + " has "
	      if(!success)
	        print "no "
	      end
	      puts "ruby methods"
      end

      return success
    end

    # turn all classes' ruby methods into their C equivalents
    # deemed unstable as of yet :(
    def Concretize.concretize_all!
    	@@already_cified = {} # in case things have changed...maybe?    
      all = []
      ObjectSpace.each_object(Class) {|c|
        worked = Concretize.c_ify_class!(c)
        all << c if worked
      }
      all
    end
  end

end

class Class
	# somewhat of a misnomer TODO rdoc
  def concretize!
    Ruby2CExtension::Concretize.c_ify_class! self
  end
end
